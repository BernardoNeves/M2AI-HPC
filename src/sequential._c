#include "sequential.h"
#include "utils.h"
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>

// int solve_sequential(const jobshop_t* jss, jobshop_solution_t* solution) {
//     solution->num_jobs = jss->num_jobs;
//     solution->num_machines = jss->num_machines;
//
//     int machine_completion_time[MAX_MACHINES] = { 0 };
//     int job_completion_time[MAX_JOBS] = { 0 };
//
//     for (int job_id = 0; job_id < jss->num_jobs; job_id++) {
//         for (int op_idx = 0; op_idx < jss->num_machines; op_idx++) {
//             int machine_id = jss->machines[job_id][op_idx];
//             int processing_time = jss->times[job_id][op_idx];
//
//             int start_time = max(machine_completion_time[machine_id],
//                 job_completion_time[job_id]);
//
//             int end_time = start_time + processing_time;
//
//             solution->schedule[job_id][op_idx].machine_id = machine_id;
//             solution->schedule[job_id][op_idx].start_time = start_time;
//             solution->schedule[job_id][op_idx].end_time = end_time;
//
//             machine_completion_time[machine_id] = end_time;
//             job_completion_time[job_id] = end_time;
//         }
//     }
//
//     int makespan = 0;
//     for (int job_id = 0; job_id < jss->num_jobs; job_id++) {
//         int job_end_time = solution->schedule[job_id][jss->num_machines - 1].end_time;
//         if (job_end_time > makespan) {
//             makespan = job_end_time;
//         }
//     }
//
//     solution->makespan = makespan;
//     return makespan;
// }

typedef struct {
    int job_id;
    int total_time;
} job_info_t;

static int calculate_job_total_time(const jobshop_t* jss, int job_id) {
    int total = 0;
    for (int op_idx = 0; op_idx < jss->num_machines; op_idx++) {
        total += jss->times[job_id][op_idx];
    }
    return total;
}

static int compare_spt(const void* a, const void* b) {
    job_info_t* job_a = (job_info_t*)a;
    job_info_t* job_b = (job_info_t*)b;
    return job_a->total_time - job_b->total_time;
}

static int compare_lpt(const void* a, const void* b) {
    job_info_t* job_a = (job_info_t*)a;
    job_info_t* job_b = (job_info_t*)b;
    return job_b->total_time - job_a->total_time;
}

static void create_job_order(const jobshop_t* jss, int* job_order, heuristic_t heuristic) {
    if (heuristic == HEURISTIC_NONE) {
        for (int i = 0; i < jss->num_jobs; i++) {
            job_order[i] = i;
        }
        return;
    }

    job_info_t job_info[MAX_JOBS];
    for (int i = 0; i < jss->num_jobs; i++) {
        job_info[i].job_id = i;
        job_info[i].total_time = calculate_job_total_time(jss, i);
    }

    switch (heuristic) {
    case HEURISTIC_SPT:
    case HEURISTIC_LWR:
        qsort(job_info, jss->num_jobs, sizeof(job_info_t), compare_spt);
        break;
    case HEURISTIC_LPT:
    case HEURISTIC_MWR:
        qsort(job_info, jss->num_jobs, sizeof(job_info_t), compare_lpt);
        break;
    default:
        break;
    }

    for (int i = 0; i < jss->num_jobs; i++) {
        job_order[i] = job_info[i].job_id;
    }
}

int solve_sequential(const jobshop_t* jss, jobshop_solution_t* solution) {
    return solve_best_heuristic(jss, solution);
    // return solve_sequential_with_heuristic(jss, solution, HEURISTIC_NONE);
}

int solve_sequential_with_heuristic(const jobshop_t* jss, jobshop_solution_t* solution, heuristic_t heuristic) {
    solution->num_jobs = jss->num_jobs;
    solution->num_machines = jss->num_machines;

    int machine_completion_time[MAX_MACHINES] = { 0 };
    int job_completion_time[MAX_JOBS] = { 0 };
    int job_order[MAX_JOBS];

    // Create job ordering based on heuristic
    create_job_order(jss, job_order, heuristic);

    // Schedule jobs in the determined order
    for (int i = 0; i < jss->num_jobs; i++) {
        int job_id = job_order[i];

        for (int op_idx = 0; op_idx < jss->num_machines; op_idx++) {
            int machine_id = jss->machines[job_id][op_idx];
            int processing_time = jss->times[job_id][op_idx];

            int start_time = max(machine_completion_time[machine_id],
                job_completion_time[job_id]);

            int end_time = start_time + processing_time;

            solution->schedule[job_id][op_idx].machine_id = machine_id;
            solution->schedule[job_id][op_idx].start_time = start_time;
            solution->schedule[job_id][op_idx].end_time = end_time;

            machine_completion_time[machine_id] = end_time;
            job_completion_time[job_id] = end_time;
        }
    }

    // Calculate makespan
    int makespan = 0;
    for (int job_id = 0; job_id < jss->num_jobs; job_id++) {
        int job_end_time = solution->schedule[job_id][jss->num_machines - 1].end_time;
        if (job_end_time > makespan) {
            makespan = job_end_time;
        }
    }

    solution->makespan = makespan;
    return makespan;
}

// Convenience function to test all heuristics
int solve_best_heuristic(const jobshop_t* jss, jobshop_solution_t* solution) {
    jobshop_solution_t temp_solution;
    int best_makespan = INT_MAX;
    heuristic_t best_heuristic = HEURISTIC_NONE;

    // Test all heuristics
    for (int h = HEURISTIC_NONE; h <= HEURISTIC_LWR; h++) {
        int makespan = solve_sequential_with_heuristic(jss, &temp_solution, (heuristic_t)h);
        if (makespan < best_makespan) {
            best_makespan = makespan;
            best_heuristic = (heuristic_t)h;
            *solution = temp_solution; // Copy best solution
        }
    }
    // printf("Best heuristic: %d with makespan: %d\n", best_heuristic, best_makespan);

    return best_makespan;
}
